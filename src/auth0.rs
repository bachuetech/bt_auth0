use std::collections::HashSet;
use std::error::Error;
use std::sync::mpsc::{Receiver, Sender};
use std::sync::mpsc;
use std::thread::{self};
use std::time::Duration;

use bt_logger::{get_error, log_error, log_verbose, log_warning};
use bt_secure_storage::hashing::get_hash_string_sha256_base64;
use bt_string_utils::generate_url_safe_string;
use chrono::Utc;
use tao::dpi::LogicalSize;
use tao::event::{Event, WindowEvent};
use tao::event_loop::{ControlFlow, EventLoop, EventLoopBuilder, EventLoopProxy};
use tao::platform::run_return::EventLoopExtRunReturn;
use tao::window::{Icon, WindowBuilder};
use wry::WebViewBuilder;
use oauth2::{AuthUrl, ClientId, ClientSecret, RedirectUrl, TokenResponse};
use oauth2::{TokenUrl, PkceCodeVerifier, AuthorizationCode};
use tiny_http::{Response, Server};
use url::Url;

use crate::auth0_config::Auth0Config;
use crate::auth0_tokens::Auth0Token;

/// The method used to generate a PKCE challenge.
/// This constant represents the name of the method that generates a code verifier and challenge pair.
pub const CODE_CHALLENGE_METHOD: &str = "S256"; ///Sha-256    

/// Generates a PKCE code verifier and challenge pair.
/// This function generates a random string to use as the code verifier, then calculates the corresponding challenge using SHA-256 (CODE_CHALLENGE_METHOD).
///
/// # Returns
/// A tuple containing the code verifier and challenge.
fn generate_pkce_pair() -> (String, String) {
    const SAMPLE_VERIFIER_SIZE: usize = 128;
    let verifier: String =  generate_url_safe_string(SAMPLE_VERIFIER_SIZE); 
    let challenge = get_hash_string_sha256_base64(&verifier); 
    (verifier, challenge)
}

///Open Auth0 Login in WebView (embedded Browser)
/// This function takes various parameters to configure the login process, such as the client ID and redirect URI.
///
/// # Parameters
/// * `app_name`: The name of the application.
/// * `app_icon`: An optional icon for the application (tao::icon).
/// * `client_id`: The ID of the Auth0 client.
/// * `challenge`: The code challenge generated by the `generate_pkce_pair` function.
/// * `redirect_uri`: The redirect URI to send the authorization code back to.
/// * `scope`: The scope of the request (e.g. "openid profile email").
/// * `auth_endpoint`: The endpoint URL for authentication.
/// * `state`: A random string used to prevent CSRF attacks.
/// * `event_loop`: EventLoop<u64> that is received once the code to retrieve the access token is completed (zero - 0). This return control to the code
fn open_auth0_webview_login(app_name: &str, app_icon: Option<Icon>, client_id: &str, challenge: &str, redirect_uri: &str, scope: &str, 
                            auth_endpoint: &str, state: &str, mut event_loop: EventLoop<u64>) -> Result<(),Box<dyn Error>>{
    log_verbose!("open_auth0_webview_login","Opening login page");

    //noance
    let nonce = generate_url_safe_string(16);

    let auth_url = format!(
            "{}?response_type=code&client_id={}&redirect_uri={}&scope={}&code_challenge={}&code_challenge_method={}&nonce={}&state={}",
            auth_endpoint, client_id, redirect_uri, scope, challenge,CODE_CHALLENGE_METHOD,nonce, state
        );        

    let window = WindowBuilder::new()
        .with_title(format!("{} Login",app_name))
        .with_window_icon(app_icon)
        .with_inner_size(LogicalSize::new(1024.0, 768.0))
        .build( &event_loop)?;

    let mut webview = Some(WebViewBuilder::new()
        .with_url(auth_url) 
        .build(&window)?);

    event_loop.run_return(move |event, _, control_flow| {
        *control_flow = ControlFlow::Wait;

        match event {
            Event::WindowEvent { event: WindowEvent::CloseRequested, .. } => {
                log_verbose!("run_event_loop","Login Window Close and Exit Requested");
                webview.take();
                *control_flow = ControlFlow::Exit;
                std::process::exit(0);
            }
            Event::UserEvent(0) => {
                webview.take();
                *control_flow = ControlFlow::Exit; //Return control
            }
            _ => {}
        }
    });
    Ok(())
}

/// Represents an internal token obtained from the Auth0 API.
/// This struct contains the access token, expiration timestamp, and scopes for the token.
struct Auth0InternalToken{
    token: String,
    exp_timestamp: usize,
    scopes: Option<HashSet<String>>
}

/// Handles the exchange of a code for an access token.
/// This function takes various parameters to configure the authentication process, such as the client secret and redirect URI.
///
/// # Parameters
/// * `code`: The authorization code obtained from the Auth0 API.
/// * `verifier`: The PKCE verifier generated by the `generate_pkce_pair` function.
/// * `client_id`: The ID of the Auth0 client.
/// * `redirect_uri`: The redirect URI to send the access token back to.
/// * `client_secret`: The secret key for the Auth0 client.
/// * `auth_endpoint`: The endpoint URL for authentication.
/// * `token_endpoint`: The endpoint URL for obtaining an access token.
/// 
/// # Returns
/// A result with the Auth0 Internal Token or an error occurred.  
fn exchange_code_for_token(code: String, verifier: String, client_id: &str, redirect_uri: &str, client_secret: &str, auth_endpoint: &str, token_endpoint: &str ) 
                                -> Result<Auth0InternalToken, Box<dyn Error>>{
    log_verbose!("exchange_code_for_token","Starting exchange");

    // Create Tokio runtime for async token exchange
    let rt = tokio::runtime::Runtime::new()?;

    let auth0_client_id = ClientId::new(client_id.to_owned());
    let auth0_client_secret = ClientSecret::new(client_secret.to_owned());
    let auth0_url = AuthUrl::new(auth_endpoint.to_owned())?;   
    let auth0_token_url =  TokenUrl::new(token_endpoint.to_owned())?;
    let auth0_redirect_uri =  RedirectUrl::new(redirect_uri.to_owned())?;
    let auth_code = AuthorizationCode::new(code.clone());


    let client = oauth2::basic::BasicClient::new(auth0_client_id)
        .set_client_secret(auth0_client_secret)
        .set_auth_uri(auth0_url)
        .set_token_uri(auth0_token_url)
        .set_redirect_uri(auth0_redirect_uri)
        ;

        let now = Utc::now().timestamp() as u64; //To use to expire token, Better expire it before time?
        let token_response = rt
        .block_on(async {
            client
            .exchange_code(auth_code)
            .set_pkce_verifier(PkceCodeVerifier::new(verifier))
            .request_async(&oauth2::reqwest::Client::new())
            .await
        })?;

    let at = token_response.access_token().secret().to_owned();
    if at.len() < 32{
        log_error!("exchange_code_for_token","Could not get a valid Access Token. Access Token is Empty");
        return Err(get_error!("exchange_code_for_token","Invalid Access Token Size.").into());
    }

    let access_token = Auth0InternalToken{
        token: at,
        exp_timestamp: (now + token_response.expires_in().unwrap_or(Duration::new(36000, 0)).as_secs()) as usize,
        scopes: token_response.scopes().map(|v| v.iter().map(|s| s.to_string()).collect())
    };
    
    return Ok(access_token);
}



/// Listens for incoming requests on a local server with the code to exchange from Auth0 authentication.
/// This function takes the event loop and port number as parameters to configure the server.
///
/// # Parameters
/// * `proxy`: to send a notification to close the window and continue Auth Flow
/// * `redirect_ports`: The port numbers of the redirect URI. It is a comma separated str with port numbers
/// 
/// #Returns:
/// * usize: Listening (redirect) port
/// * Receiver<String>: Listening for event to exit
fn listen_for_auth_code(proxy: EventLoopProxy<u64>, redirect_ports: &Vec<usize>) -> Result<(usize,Receiver<String>), Box<dyn Error>> {
    let ports: Vec<usize> = redirect_ports.clone(); //Required clone due to thread::spawn(move || 
    let mut choosen_redirect_port = ports[0];    
    let (tx, rx): (Sender<String>, Receiver<String>) = mpsc::channel();

    let mut redirect_server_address = format!("127.0.0.1:{}",choosen_redirect_port);
    let mut svr = Server::http(&redirect_server_address);
    
    while svr.is_err() {
        for port in ports.clone(){
            redirect_server_address = format!("127.0.0.1:{}",port);
            svr = Server::http(&redirect_server_address);
            if svr.is_ok(){
                log_verbose!("listen_for_auth_code","Starting Local Server {}",redirect_server_address); 
                choosen_redirect_port = port;              
                break;
            }else{
                log_verbose!("listen_for_auth_code","Cannot start server at '{}'",redirect_server_address);
            }
        }

        if svr.is_err() {
            choosen_redirect_port = ports[0];                  
            log_error!("listen_for_auth_code","Could not initialize localserver to redirect requests. Last try with default port 0 '{}'",choosen_redirect_port);
            redirect_server_address = format!("127.0.0.1:{}",choosen_redirect_port);
            svr = Server::http(&redirect_server_address);
            if svr.is_err() {
                log_error!("listen_for_auth_code","Unable to start local server to receive redirections. Must exits now!");
                return Err(get_error!("listen_for_auth_code","Unable to start local server to receive redirections.").into())             
            }
        }
    }

    thread::spawn(move || {
        log_verbose!("listen_for_auth_code","Starting Local Server in port {}",choosen_redirect_port); 
        let server: Server = svr.expect("Failed to start server with available port");

        for request in server.incoming_requests() {
            // Parse the full request URL
            let full_url = format!("http://localhost{}", request.url());
            if let Ok(parsed_url) = Url::parse(&full_url){ 
                // Extract the `code` query parameter
                if let Some(code) = parsed_url.query_pairs().find(|(key, _)| key == "code") {
                    // Respond to browser
                    let html = "Successful Authentication! You can close this window.";
                    let response = Response::from_string(html)
                                                                .with_status_code(200);
                    
                    let _ = tx.send(code.1.to_string()); //Send code as Answer
                    let _ = request.respond(response); //"Show Response"
                    let _ = proxy.send_event(0); //Send Close Auth0 Login Window Notification. Must be here to allow code to continue!
                    break; //Exit the Thread
                } else {
                    // Respond with error if no code found
                    log_warning!("listen_for_auth_code","answer {:?}",request);
                    let response = Response::from_string("Missing code parameter")
                        .with_status_code(400);
                    let _ = request.respond(response);
                }
            }else{
                // Respond with 422 error cannot parse URL - Unprocessable Content
                log_error!("listen_for_auth_code","Failed to parse URL {}",full_url);
                let response = Response::from_string("Invalid URL")
                    .with_status_code(422);
                let _ = request.respond(response);
            }
        }

    });
    log_verbose!("listen_for_auth_code","Returning rx");
    return Ok( (choosen_redirect_port, rx) );
}


/// Triggers the OAuth flow and returns an access token.
///
/// This function takes various parameters to configure the authentication process, such as the client ID and redirect URI.
///
/// # Parameters
///
/// * `env_profile`: The environment profile for the application (e.g. dev, prod).
/// * `app_name`: The name of the application.
/// * `app_icon`: An optional icon for the application (tao::icon).
/// * `auth0_config`: The Auth0 configuration data.
/// * `scope`: The scope of the request (e.g. "openid profile email").
/// * `auth0keys_yaml`: The content of the YAML file containing the Auth0 encryption key.
/// 
/// # Returns: Access Token (String) or Error
pub fn launch_auth_flow(env_profile: &str, app_name: &str, app_icon: Option<Icon>, auth0_config: &Auth0Config, scope: &str, auth0keys_yaml: &str) 
                                    -> Result<Auth0Token, Box<dyn Error>> {                                    
    let (verifier, challenge) = generate_pkce_pair();
    let state = generate_url_safe_string(16);

    let event_loop: EventLoop<u64> = EventLoopBuilder::with_user_event().build();
    let proxy = event_loop.create_proxy();
    let (redirect_port,rx_code) = listen_for_auth_code(proxy, &auth0_config.get_redirect_port())?; //MUST have proxy to close the window and continue Auth Flow!

    // Block until server sends code
    let _login_window = open_auth0_webview_login(app_name, app_icon, &auth0_config.get_client_id(), &challenge,&auth0_config.get_redirect_uri(redirect_port),
                                                        scope, &auth0_config.get_authorize_url(), &state, event_loop)?;
    log_verbose!("launch_auth_flow","Waiting for authorization code from server thread...");
    let code = rx_code.recv()?; //Waiting for code

    let resp_token = exchange_code_for_token(code, verifier, &auth0_config.get_client_id(), &auth0_config.get_redirect_uri(redirect_port), 
                                                                    &auth0_config.get_client_secret(), &auth0_config.get_authorize_url(),
                                                                &auth0_config.get_token_url())?;

    let mut token = Auth0Token::new(env_profile,resp_token.token, resp_token.exp_timestamp, resp_token.scopes, auth0keys_yaml)?;

    let _ = token.refresh_userinfo(&auth0_config.get_userinfo_url());

    Ok(token)
}